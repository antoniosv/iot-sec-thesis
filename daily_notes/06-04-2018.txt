--------------------------------
Enforcing authentication in OSGI with JAX-RS annotations
--------------------------------

So far, it seems that the current codebase is supposed to handle basic and jwt authentication through the bundles/auth/ code.
Example, if I used:
$ curl -H 'Authorization: Bearer (token)' http://localhost:8080/rest/items
Then it should return a 200 OK response if the token is valid. Otherwise, it would return an error 500 saying that the signature is invalid.
This check should be done because the items endpoint is annotated with the @RolesAllowed('admin') role.

However, the authentication is not being done. It is bypassed for me reason, even if there is no token. The same goes for the basic-authentication requiring username:password.

It's not entirely clear what could fix this. Maybe there is some kind of configuration or perhaps there is some bundle that is not being registered to the runtime.
One stackoverflow post suggests that extending the REST resource classes to the RolesAllowedDynamicFeature interface fixes the problem.

This example of the osgi jax-rs connector shows how the annotation works:
https://github.com/hstaudacher/osgi-jax-rs-connector/tree/master/examples/com.eclipsesource.jaxrs.security.example

According to another stackoverflow post:
"Make sure you have your AuthorizationFilter either registered in your MyApplication (see Registering Resources and Providers in Jersey 2) or annotated with @Provider (to make it discoverable by package scanning)."  https://stackoverflow.com/questions/21536321/securitycontext-doesnt-work-with-rolesallowed

More information on the Jersey implementation https://jersey.github.io/documentation/latest/security.html#d0e12428

Something like this may need to be done:
resourceConfig.register(RolesAllowedDynamicFeature.class);
but in the ESH way, e.g. bc.register(...)

--------------------------
OSGi R6 Specification
--------------------------

Two relevant aspects: http-whiteboard pattern and filter registration.

Http whiteboard:
Chapter 140 of the OSGi R4 Compendium.
Can be used to register servlets, servlet filters, resources, and servlet listeners.

â€¢ Servlet Filter - Can be used to augment or transform web resources or for cross-cutting functionality such as security, common widgets or otherwise.

Servlet filters:
Servlet filters provide a mechanism to intercept servlet invocations. They support modifying the ServletRequest and ServletResponse objects and are often used to augment web pages generated by servlets, for example with a common header or footer. Servlet filters can also be used to handle security, do logging or transform the content produced by a servlet to a certain format.

---------------------
Whiteboard pattern
--------------------
Why is the whiteboard important in R6 and for openhab? To register servlets to make their features available, you need to have an http service active and tracked. If it is not available (perhaps bundle started too soon), then it can get more complex. With the whiteboard pattern, each servlet has a context and a http service to register itself to. Therefore, it's much more convenient to  have the whiteboard extender to register services. The whiteboard pattern was not available on osgi 4.2. Only from R6 and onwards. Thus, ESH does not have this capability. However, OH2 runs  under osgi R6 (karaf?), so it is compatible.
Suggestion by Lukasz was to make use of this whiteboard in OH2 to make a filter available (to catch http requests), to provide an authentication mechanism. Then, it can be used to enforce authorization with it. Pax-web implements the whiteboard extender thing. 
An introduction on whiteboard in pax-web: https://ops4j1.jira.com/wiki/spaces/ops4j/pages/5046828/Pax+Web+Extender+-+Whiteboard

---------------------
Developing components
---------------------

There are several ways to develop components and services for osgi: bluepring, iPojo, Dependency Manager, Declarative Services (DS), etc. Declarative Services is the standard maintained by the OSGi alliance.

An XML for the DS is required to identify which classes make up the components and which services they provide.

Interactions between components is done via services.
